const SECRET_TOKEN = 's3cUr3T0kasd34653n!@#45dsfg67890'; // Ersetze dies durch dein starkes Token
const PROCESSED_FOLDER_ID = '1LpfMRuyarLzKAHtzhjU3dLVqG4mpZoUs'; // Ersetze dies durch deine verarbeitete Ordner-ID

/**
 * HTTP POST-Handler für den Webhook.
 * Erwartet JSON-Daten mit 'docId' und 'token'.
 */
function doPost(e) {
  try {
    // Überprüfen, ob Daten gesendet wurden
    if (!e.postData || !e.postData.contents) {
      throw new Error('Keine Daten empfangen.');
    }

    // Parsen der JSON-Daten
    const data = JSON.parse(e.postData.contents);
    const { docId, token } = data;

    // Sicherheitsüberprüfung
    if (token !== SECRET_TOKEN) {
      throw new Error('Unbefugter Zugriff.');
    }

    // Überprüfen, ob docId vorhanden ist
    if (!docId) {
      throw new Error('Dokumenten-ID fehlt.');
    }

    // Dokument öffnen und verarbeiten
    processDocument(docId);

    // Erfolgreiche Antwort zurücksenden
    return ContentService
      .createTextOutput(JSON.stringify({ status: 'success', message: 'Dokument verarbeitet und verschoben.' }))
      .setMimeType(ContentService.MimeType.JSON);

  } catch (error) {
    // Fehlerhafte Antwort zurücksenden
    return ContentService
      .createTextOutput(JSON.stringify({ status: 'error', message: error.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Verarbeitet das Dokument anhand der angegebenen Dokumenten-ID.
 * @param {string} docId - Die Dokumenten-ID des zu verarbeitenden Dokuments.
 */
function processDocument(docId) {
  try {
    convertMarkdownAndCleanUp(docId);
    moveDocumentToProcessedFolder(docId);
  } catch (error) {
    throw error; // Weiterwerfen des Fehlers, damit doPost ihn fängt
  }
}

/**
 * Verschiebt das verarbeitete Dokument in den festgelegten Ordner.
 * @param {string} docId - Die Dokumenten-ID des zu verschiebenden Dokuments.
 */
function moveDocumentToProcessedFolder(docId) {
  try {
    const processedFolder = DriveApp.getFolderById(PROCESSED_FOLDER_ID);
    const file = DriveApp.getFileById(docId);
    file.moveTo(processedFolder);
  } catch (error) {
    throw new Error(`Fehler beim Verschieben des Dokuments mit ID ${docId}: ${error.message}`);
  }
}

/**
 * Hauptfunktion zur Konvertierung von Markdown, Entfernen leerer Absätze und Hinzufügen von Zeilenabständen nach Listen.
 * @param {string} docId - Die Dokumenten-ID des zu verarbeitenden Dokuments.
 */
function convertMarkdownAndCleanUp(docId) {
  try {
    const doc = DocumentApp.openById(docId);
    if (!doc) {
      throw new Error(`Dokument mit der ID ${docId} konnte nicht geöffnet werden.`);
    }
    const body = doc.getBody();
    if (!body) {
      throw new Error(`Dokument mit der ID ${docId} hat keinen Body.`);
    }
    const totalElements = body.getNumChildren();

    // Basiswerte für Einzüge
    const baseIndentStart = 30; // Basis linker Einzug in Punkten
    const indentReductionPerLevel = 5; // Reduktion des linken Einzugs pro Einzugsebene
    const baseIndentFirstLine = 8; // Basis hängender Einzug in Punkten
    const indentFirstLineReductionPerLevel = 1; // Reduktion des hängenden Einzugs pro Ebene

    // Arrays zur Speicherung von Änderungen
    const lastListItemIndices = [];
    const emptyParagraphIndices = [];

    // Durchlaufe alle Elemente im Dokument
    for (let i = 0; i < totalElements; i++) {
      const element = body.getChild(i);
      const elementType = element.getType();

      if (elementType === DocumentApp.ElementType.PARAGRAPH) {
        const paragraph = element.asParagraph();
        const text = paragraph.getText();

        // Überschriften erkennen und umwandeln
        const headerMatch = text.match(/^(#{1,6})\s*(.*)/);
        if (headerMatch) {
          const headerLevel = headerMatch[1].length;
          const headerText = headerMatch[2];

          paragraph.clear().setText(headerText);
          paragraph.setHeading(getHeadingType(headerLevel));
          continue;
        }

        // Listen erkennen und umwandeln
        const listMatch = text.match(/^(\s*)([-*+]|\d+\.)\s+(.*)/);
        if (listMatch) {
          const leadingSpaces = listMatch[1].length;
          const indentLevel = Math.floor(leadingSpaces / 2); // Jeder 2 Leerzeichen = eine Einzugsebene
          const bulletType = listMatch[2];
          const listItemText = listMatch[3];

          // Entferne den aktuellen Absatz und ersetze ihn durch einen ListItem
          body.removeChild(element);
          const listItem = body.insertListItem(i, listItemText);

          // Listenart festlegen
          listItem.setGlyphType(
            bulletType.match(/^[-*+]$/) ? DocumentApp.GlyphType.BULLET : DocumentApp.GlyphType.NUMBER
          );

          // Einzugsebene und Einzüge setzen
          listItem.setNestingLevel(indentLevel);
          listItem.setIndentStart(Math.max(baseIndentStart - (indentLevel * indentReductionPerLevel), 0));
          listItem.setIndentFirstLine(Math.max(baseIndentFirstLine - (indentLevel * indentFirstLineReductionPerLevel), 0));

          // Inline-Formatierungen anwenden
          applyTextFormatting(listItem);

          // Überprüfen, ob dies das letzte ListItem in der aktuellen Liste ist
          if (i + 1 === body.getNumChildren()) {
            // Letztes Element im Dokument ist ein ListItem
            lastListItemIndices.push(i);
          } else {
            const nextElement = body.getChild(i + 1);
            if (nextElement.getType() !== DocumentApp.ElementType.LIST_ITEM ||
                nextElement.asListItem().getNestingLevel() < indentLevel) {
              lastListItemIndices.push(i);
            }
          }

          continue;
        }

        // Entferne unsichtbare Zeichen und prüfe auf leeren Absatz
        const cleanText = text.replace(/\u200B/g, '').replace(/\s/g, '').trim();

        // Prüfen, ob der Absatz nach der Bereinigung leer ist
        if (cleanText === "" && i !== totalElements - 1) {
          emptyParagraphIndices.push(i);
        } else {
          // Inline-Formatierungen (fett, kursiv) anwenden
          applyTextFormatting(paragraph);
        }
      }
    }

    // Setze Zeilenabstand nach den letzten ListItems
    setSpacingAfterLastListItems(body, lastListItemIndices, 12);

    // Entferne leere Absätze, außer dem letzten
    removeEmptyParagraphs(body, emptyParagraphIndices);

    // Speichere das Dokument nach allen Änderungen
    doc.saveAndClose();

  } catch (error) {
    throw new Error(`Fehler in convertMarkdownAndCleanUp: ${error.message}`);
  }
}

/**
 * Gibt den entsprechenden ParagraphHeading-Typ basierend auf der Überschriftenebene zurück.
 * @param {number} level - Die Überschriftenebene (1 bis 6).
 * @return {DocumentApp.ParagraphHeading} - Der entsprechende ParagraphHeading-Typ.
 */
function getHeadingType(level) {
  switch (level) {
    case 1:
      return DocumentApp.ParagraphHeading.HEADING1;
    case 2:
      return DocumentApp.ParagraphHeading.HEADING2;
    case 3:
      return DocumentApp.ParagraphHeading.HEADING3;
    case 4:
      return DocumentApp.ParagraphHeading.HEADING4;
    case 5:
      return DocumentApp.ParagraphHeading.HEADING5;
    case 6:
      return DocumentApp.ParagraphHeading.HEADING6;
    default:
      return DocumentApp.ParagraphHeading.NORMAL;
  }
}

/**
 * Wendet fett und kursiv Formatierungen basierend auf Markdown-Syntax an.
 * @param {ListItem|Paragraph} element - Das ListItem- oder Paragraph-Element, das formatiert werden soll.
 */
function applyTextFormatting(element) {
  const textElement = element.asText();
  let text = textElement.getText();

  // Fett (**text**)
  const boldRegex = /\*\*(.+?)\*\*/g;
  let matches;
  while ((matches = boldRegex.exec(text)) !== null) {
    const matchText = matches[0];
    const content = matches[1];
    const start = matches.index;
    const end = start + matchText.length - 1;

    // Fett formatieren
    textElement.deleteText(start, end);
    const insertedText = textElement.insertText(start, content);
    if (insertedText) {
      insertedText.setBold(start, start + content.length - 1, true);
    }

    // Aktualisiere den Text und setze die Position für den nächsten Treffer
    text = textElement.getText();
    boldRegex.lastIndex = start + content.length;
  }

  // Kursiv (*text*)
  const italicRegex = /\*(?!\*)(.+?)\*/g; // Verhindert, dass **text** als *text* erkannt wird
  while ((matches = italicRegex.exec(text)) !== null) {
    const matchText = matches[0];
    const content = matches[1];
    const start = matches.index;
    const end = start + matchText.length - 1;

    // Kursiv formatieren
    textElement.deleteText(start, end);
    const insertedText = textElement.insertText(start, content);
    if (insertedText) {
      insertedText.setItalic(start, start + content.length - 1, true);
    }

    // Aktualisiere den Text und setze die Position für den nächsten Treffer
    text = textElement.getText();
    italicRegex.lastIndex = start + content.length;
  }
}

/**
 * Setzt den gewünschten Zeilenabstand nach den letzten ListItems.
 * @param {Body} body - Das Dokumentenbody-Element.
 * @param {Array<number>} indices - Die Indizes der letzten ListItems.
 * @param {number} spacingPoints - Der gewünschte Zeilenabstand in Punkten.
 */
function setSpacingAfterLastListItems(body, indices, spacingPoints) {
  try {
    indices.forEach(index => {
      if (index < body.getNumChildren()) {
        const listItem = body.getChild(index).asListItem();
        listItem.setSpacingAfter(spacingPoints);
      }
    });
  } catch (error) {
    throw new Error(`Fehler in setSpacingAfterLastListItems: ${error.message}`);
  }
}

/**
 * Entfernt alle leeren Absätze im Dokument, außer dem letzten Absatz.
 * @param {Body} body - Das Dokumentenbody-Element.
 * @param {Array<number>} emptyIndices - Die Indizes der leeren Absätze, die entfernt werden sollen.
 */
function removeEmptyParagraphs(body, emptyIndices) {
  if (!Array.isArray(emptyIndices) || emptyIndices.length === 0) {
    return; // Keine leeren Absätze vorhanden, keine Aktion erforderlich
  }

  // Sortiere die Indizes absteigend, um das Entfernen korrekt zu machen
  emptyIndices.sort(function(a, b) { return b - a; });

  // Leere Absätze entfernen
  emptyIndices.forEach(index => {
    if (index < body.getNumChildren() - 1) {
      body.removeChild(body.getChild(index));
    }
  });
}

/**
 * Testfunktion zur manuellen Ausführung von doPost mit einem Mock-Ereignisobjekt.
 */
function testDoPost() {
  var mockEvent = {
    postData: {
      type: 'application/json',
      contents: JSON.stringify({
        docId: '1pCdJ52gi2lM8lCH1glbfmEDHBb6Xu6uk8wH9ULCcfNI', // Ersetze dies durch deine tatsächliche Dokumenten-ID
        token: 's3cUr3T0k3n!@#4567890'    // Ersetze dies durch dein tatsächliches Secret Token
      })
    }
  };
  
  // Aufruf von doPost mit dem Mock-Ereignisobjekt
  var response = doPost(mockEvent);
  
  // Ausgabe der Antwort in den Logs
  Logger.log(response.getContent());
}

/**
 * Testfunktion zur manuellen Ausführung von processDocument mit einer spezifischen Dokumenten-ID.
 */
function testProcessDocument() {
  var docId = '1pCdJ52gi2lM8lCH1glbfmEDHBb6Xu6uk8wH9ULCcfNI'; // Ersetze dies durch deine tatsächliche Dokumenten-ID
  processDocument(docId);
}
